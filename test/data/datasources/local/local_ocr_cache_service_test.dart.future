import 'dart:typed_data';
import 'dart:convert';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:uuid/uuid.dart';

import 'package:busines_card_scanner_flutter/domain/entities/ocr_result.dart';
import 'package:busines_card_scanner_flutter/domain/repositories/ocr_repository.dart';
import 'package:busines_card_scanner_flutter/domain/exceptions/repository_exceptions.dart';
import 'package:busines_card_scanner_flutter/data/datasources/local/local_ocr_cache_service.dart';
import 'package:busines_card_scanner_flutter/data/datasources/local/app_database.dart';

/// LocalOCRCacheService ÁöÑÂÆåÊï¥Ê∏¨Ë©¶Â•ó‰ª∂
/// 
/// ÈÅµÂæ™ TDD Red-Green-Refactor ÈñãÁôºÊµÅÁ®ã
/// Ê∂µËìãÊâÄÊúâÊñπÊ≥ïÁöÑÊàêÂäü/Â§±ÊïóÂ†¥ÊôØÂíåÈÇäÁïåÊ¢ù‰ª∂
/// ‰ΩøÁî®ÂØ¶ÈöõÁöÑ Drift Ë®òÊÜ∂È´îË≥áÊñôÂ∫´ÈÄ≤Ë°åÊï¥ÂêàÊ∏¨Ë©¶

// Mock classes using mocktail
class MockUuid extends Mock implements Uuid {}

void main() {
  group('LocalOCRCacheService - TDD Ê∏¨Ë©¶Â•ó‰ª∂', () {
    late LocalOCRCacheService cacheService;
    late AppDatabase database;
    late MockUuid mockUuid;
    
    // Ê∏¨Ë©¶Ë≥áÊñô
    late OCRResult testOCRResult;
    late Uint8List testImageData;
    late String testCacheKey;

    setUp(() async {
      // ‰ΩøÁî®Ë®òÊÜ∂È´îË≥áÊñôÂ∫´ÈÄ≤Ë°åÊ∏¨Ë©¶
      database = AppDatabase(NativeDatabase.memory());
      mockUuid = MockUuid();
      
      cacheService = LocalOCRCacheService(
        database: database,
        uuid: mockUuid,
        cacheValidityDays: 7,
      );

      // Ê∫ñÂÇôÊ∏¨Ë©¶Ë≥áÊñô
      testImageData = Uint8List.fromList([
        0xFF, 0xD8, 0xFF, 0xE0, // JPEG header
        ...List.generate(100, (i) => i % 256),
      ]);
      
      testCacheKey = 'test_cache_key_001';
      
      testOCRResult = OCRResult(
        id: 'test-ocr-001',
        rawText: 'Âºµ‰∏â\nABCÁßëÊäÄÂÖ¨Âè∏\nÁî¢ÂìÅÁ∂ìÁêÜ\n02-1234-5678',
        detectedTexts: ['Âºµ‰∏â', 'ABCÁßëÊäÄÂÖ¨Âè∏', 'Áî¢ÂìÅÁ∂ìÁêÜ', '02-1234-5678'],
        confidence: 0.95,
        imageData: testImageData,
        imageWidth: 800,
        imageHeight: 600,
        processedAt: DateTime(2024, 8, 12, 10, 30),
        processingTimeMs: 1200,
        ocrEngine: 'google_ml_kit',
      );
    });

    tearDown(() async {
      await database.close();
    });
    
    group('getCacheKey', () {
      test('should generate consistent cache key for same image', () {
        // Act
        final key1 = cacheService.getCacheKey(testImageData);
        final key2 = cacheService.getCacheKey(testImageData);

        // Assert
        expect(key1, equals(key2));
        expect(key1, isA<String>());
        expect(key1.length, greaterThan(0));
      });

      test('should generate different cache keys for different images', () {
        // Arrange
        final imageData1 = Uint8List.fromList([1, 2, 3, 4, 5]);
        final imageData2 = Uint8List.fromList([6, 7, 8, 9, 10]);

        // Act
        final key1 = cacheService.getCacheKey(imageData1);
        final key2 = cacheService.getCacheKey(imageData2);

        // Assert
        expect(key1, isNot(equals(key2)));
      });

      test('should generate SHA-256 hash as cache key', () {
        // Act
        final key = cacheService.getCacheKey(testImageData);

        // Assert
        // SHA-256 hash ÊáâË©≤ÊòØ 64 ÂÄãÂ≠óÁ¨¶ÁöÑÂçÅÂÖ≠ÈÄ≤‰ΩçÂ≠ó‰∏≤
        expect(key.length, equals(64));
        expect(RegExp(r'^[a-f0-9]+$').hasMatch(key), isTrue);
      });

      test('should handle empty image data', () {
        // Arrange
        final emptyData = Uint8List(0);

        // Act
        final key = cacheService.getCacheKey(emptyData);

        // Assert
        expect(key, isA<String>());
        expect(key.length, equals(64)); // SHA-256 of empty data
      });
    });

    group('cacheResult and getCachedResult', () {
      test('should cache and retrieve OCR result successfully', () async {
        // Arrange
        final cacheKey = cacheService.getCacheKey(testImageData);

        // Act - Cache the result
        await cacheService.cacheResult(cacheKey, testOCRResult);

        // Act - Retrieve the cached result
        final cachedResult = await cacheService.getCachedResult(cacheKey);

        // Assert
        expect(cachedResult.rawText, equals(testOCRResult.rawText));
        expect(cachedResult.detectedTexts, equals(testOCRResult.detectedTexts));
        expect(cachedResult.confidence, equals(testOCRResult.confidence));
        expect(cachedResult.imageWidth, equals(testOCRResult.imageWidth));
        expect(cachedResult.imageHeight, equals(testOCRResult.imageHeight));
        expect(cachedResult.ocrEngine, equals(testOCRResult.ocrEngine));
        expect(cachedResult.imageData, isNotNull);
      });

      test('should throw OCRResultNotFoundException when cache miss', () async {
        // Act & Assert
        await expectLater(
          cacheService.getCachedResult('non_existent_key'),
          throwsA(isA<OCRResultNotFoundException>().having(
            (failure) => failure.userMessage,
            'userMessage',
            contains('Êâæ‰∏çÂà∞Âø´ÂèñÁöÑ OCR ÁµêÊûú'),
          )),
        );
      });

      test('should handle OCR result without image data', () async {
        // Arrange
        final resultWithoutImage = testOCRResult.copyWith(imageData: null);
        final cacheKey = cacheService.getCacheKey(testImageData);

        // Act
        await cacheService.cacheResult(cacheKey, resultWithoutImage);
        final cachedResult = await cacheService.getCachedResult(cacheKey);

        // Assert
        expect(cachedResult.imageData, isNull);
        expect(cachedResult.rawText, equals(resultWithoutImage.rawText));
      });

      test('should handle OCR result without detected texts', () async {
        // Arrange
        final resultWithoutTexts = testOCRResult.copyWith(detectedTexts: null);
        final cacheKey = cacheService.getCacheKey(testImageData);

        // Act
        await cacheService.cacheResult(cacheKey, resultWithoutTexts);
        final cachedResult = await cacheService.getCachedResult(cacheKey);

        // Assert
        expect(cachedResult.detectedTexts, isNull);
        expect(cachedResult.rawText, equals(resultWithoutTexts.rawText));
      });

      test('should throw DataSourceFailure for empty cache key', () async {
        // Act & Assert
        await expectLater(
          cacheService.cacheResult('', testOCRResult),
          throwsA(isA<DataSourceFailure>().having(
            (failure) => failure.userMessage,
            'userMessage',
            contains('Âø´ÂèñÈçµÂÄº‰∏çËÉΩÁÇ∫Á©∫'),
          )),
        );
      });

      test('should throw DataSourceFailure for oversized image data', () async {
        // Arrange
        final oversizedImage = Uint8List(15 * 1024 * 1024); // 15MB > 10MB limit
        final resultWithOversizedImage = testOCRResult.copyWith(imageData: oversizedImage);
        final cacheKey = cacheService.getCacheKey(testImageData);

        // Act & Assert
        await expectLater(
          cacheService.cacheResult(cacheKey, resultWithOversizedImage),
          throwsA(isA<DataSourceFailure>().having(
            (failure) => failure.userMessage,
            'userMessage',
            contains('ÂúñÁâáË≥áÊñôÈÅéÂ§ß'),
          )),
        );
      });
    });

    group('isCacheValid', () {
      test('should return true for valid recent result', () {
        // Arrange
        final recentResult = testOCRResult.copyWith(
          processedAt: DateTime.now().subtract(const Duration(days: 3)),
        );

        // Act
        final isValid = cacheService.isCacheValid(recentResult);

        // Assert
        expect(isValid, isTrue);
      });

      test('should return false for expired result', () {
        // Arrange
        final expiredResult = testOCRResult.copyWith(
          processedAt: DateTime.now().subtract(const Duration(days: 10)),
        );

        // Act
        final isValid = cacheService.isCacheValid(expiredResult);

        // Assert
        expect(isValid, isFalse);
      });

      test('should return false for result with empty text', () {
        // Arrange
        final emptyTextResult = testOCRResult.copyWith(rawText: '');

        // Act
        final isValid = cacheService.isCacheValid(emptyTextResult);

        // Assert
        expect(isValid, isFalse);
      });

      test('should return false for result with very low confidence', () {
        // Arrange
        final lowConfidenceResult = testOCRResult.copyWith(confidence: 0.05);

        // Act
        final isValid = cacheService.isCacheValid(lowConfidenceResult);

        // Assert
        expect(isValid, isFalse);
      });

      test('should return true for result with acceptable low confidence', () {
        // Arrange
        final acceptableResult = testOCRResult.copyWith(confidence: 0.15);

        // Act
        final isValid = cacheService.isCacheValid(acceptableResult);

        // Assert
        expect(isValid, isTrue);
      });
    });

    group('saveResult', () {
      test('should save OCR result with generated ID', () async {
        // Arrange
        const generatedId = 'generated-uuid-001';
        when(() => mockUuid.v4()).thenReturn(generatedId);

        // Act
        final savedResult = await cacheService.saveResult(testOCRResult);

        // Assert
        expect(savedResult.id, equals(generatedId));
        expect(savedResult.rawText, equals(testOCRResult.rawText));
        
        // È©óË≠âÊòØÂê¶ÁúüÁöÑÂÑ≤Â≠òÂà∞Ë≥áÊñôÂ∫´
        final retrievedResult = await cacheService.getResultById(generatedId, includeImage: true);
        expect(retrievedResult.rawText, equals(testOCRResult.rawText));
      });

      test('should update statistics when saving result', () async {
        // Arrange
        const generatedId = 'generated-uuid-002';
        when(() => mockUuid.v4()).thenReturn(generatedId);

        // Act
        await cacheService.saveResult(testOCRResult);
        final stats = await cacheService.getStatistics();

        // Assert
        expect(stats.totalProcessed, equals(1));
        expect(stats.averageConfidence, equals(testOCRResult.confidence));
        expect(stats.engineUsage[testOCRResult.ocrEngine!], equals(1));
      });
    });

    group('getHistory', () {
      test('should return empty list when no history exists', () async {
        // Act
        final history = await cacheService.getHistory();

        // Assert
        expect(history, isEmpty);
      });

      test('should return history in descending order by processed time', () async {
        // Arrange
        const id1 = 'history-001';
        const id2 = 'history-002';
        const id3 = 'history-003';
        
        when(() => mockUuid.v4())
            .thenReturnInOrder([id1, id2, id3]);

        final result1 = testOCRResult.copyWith(
          processedAt: DateTime(2024, 8, 10),
          rawText: 'First result',
        );
        final result2 = testOCRResult.copyWith(
          processedAt: DateTime(2024, 8, 12),
          rawText: 'Second result',
        );
        final result3 = testOCRResult.copyWith(
          processedAt: DateTime(2024, 8, 11),
          rawText: 'Third result',
        );

        await cacheService.saveResult(result1);
        await cacheService.saveResult(result2);
        await cacheService.saveResult(result3);

        // Act
        final history = await cacheService.getHistory();

        // Assert
        expect(history, hasLength(3));
        expect(history[0].rawText, equals('Second result')); // ÊúÄÊñ∞ÁöÑ
        expect(history[1].rawText, equals('Third result'));  // ‰∏≠ÈñìÁöÑ
        expect(history[2].rawText, equals('First result'));  // ÊúÄËàäÁöÑ
      });

      test('should respect limit parameter', () async {
        // Arrange
        for (int i = 0; i < 5; i++) {
          when(() => mockUuid.v4()).thenReturn('history-$i');
          await cacheService.saveResult(testOCRResult.copyWith(
            rawText: 'Result $i',
            processedAt: DateTime.now().add(Duration(minutes: i)),
          ));
        }

        // Act
        final history = await cacheService.getHistory(limit: 3);

        // Assert
        expect(history, hasLength(3));
      });

      test('should exclude image data by default', () async {
        // Arrange
        when(() => mockUuid.v4()).thenReturn('history-no-image');
        await cacheService.saveResult(testOCRResult);

        // Act
        final history = await cacheService.getHistory();

        // Assert
        expect(history, hasLength(1));
        expect(history[0].imageData, isNull);
      });

      test('should include image data when requested', () async {
        // Arrange
        when(() => mockUuid.v4()).thenReturn('history-with-image');
        await cacheService.saveResult(testOCRResult);

        // Act
        final history = await cacheService.getHistory(includeImages: true);

        // Assert
        expect(history, hasLength(1));
        expect(history[0].imageData, isNotNull);
        expect(history[0].imageData, equals(testImageData));
      });

      test('should throw DataSourceFailure for invalid limit', () async {
        // Act & Assert
        await expectLater(
          cacheService.getHistory(limit: 0),
          throwsA(isA<DataSourceFailure>().having(
            (failure) => failure.userMessage,
            'userMessage',
            contains('ÈôêÂà∂Êï∏ÈáèÂøÖÈ†àÂ§ßÊñº 0'),
          )),
        );

        await expectLater(
          cacheService.getHistory(limit: -5),
          throwsA(isA<DataSourceFailure>()),
        );
      });
    });

    group('getResultById', () {
      test('should retrieve result by ID successfully', () async {
        // Arrange
        const testId = 'test-get-by-id-001';
        when(() => mockUuid.v4()).thenReturn(testId);
        await cacheService.saveResult(testOCRResult);

        // Act
        final result = await cacheService.getResultById(testId);

        // Assert
        expect(result.id, equals(testId));
        expect(result.rawText, equals(testOCRResult.rawText));
      });

      test('should retrieve result with image data when requested', () async {
        // Arrange
        const testId = 'test-get-by-id-002';
        when(() => mockUuid.v4()).thenReturn(testId);
        await cacheService.saveResult(testOCRResult);

        // Act
        final result = await cacheService.getResultById(testId, includeImage: true);

        // Assert
        expect(result.imageData, isNotNull);
        expect(result.imageData, equals(testImageData));
      });

      test('should exclude image data by default', () async {
        // Arrange
        const testId = 'test-get-by-id-003';
        when(() => mockUuid.v4()).thenReturn(testId);
        await cacheService.saveResult(testOCRResult);

        // Act
        final result = await cacheService.getResultById(testId);

        // Assert
        expect(result.imageData, isNull);
      });

      test('should throw OCRResultNotFoundException for non-existent ID', () async {
        // Act & Assert
        await expectLater(
          cacheService.getResultById('non-existent-id'),
          throwsA(isA<OCRResultNotFoundException>().having(
            (failure) => failure.userMessage,
            'userMessage',
            contains('Êâæ‰∏çÂà∞ÊåáÂÆöÁöÑ OCR ÁµêÊûú'),
          )),
        );
      });

      test('should throw DataSourceFailure for empty result ID', () async {
        // Act & Assert
        await expectLater(
          cacheService.getResultById(''),
          throwsA(isA<DataSourceFailure>().having(
            (failure) => failure.userMessage,
            'userMessage',
            contains('ÁµêÊûú ID ‰∏çËÉΩÁÇ∫Á©∫'),
          )),
        );
      });
    });

    group('deleteResult', () {
      test('should delete result successfully', () async {
        // Arrange
        const testId = 'test-delete-001';
        when(() => mockUuid.v4()).thenReturn(testId);
        await cacheService.saveResult(testOCRResult);

        // Verify result exists
        final resultBeforeDelete = await cacheService.getResultById(testId);
        expect(resultBeforeDelete, isNotNull);

        // Act
        final deleteSuccess = await cacheService.deleteResult(testId);

        // Assert
        expect(deleteSuccess, isTrue);
        
        // Verify result no longer exists
        await expectLater(
          cacheService.getResultById(testId),
          throwsA(isA<OCRResultNotFoundException>()),
        );
      });

      test('should return false when deleting non-existent result', () async {
        // Act
        final deleteSuccess = await cacheService.deleteResult('non-existent-id');

        // Assert
        expect(deleteSuccess, isFalse);
      });

      test('should throw DataSourceFailure for empty result ID', () async {
        // Act & Assert
        await expectLater(
          cacheService.deleteResult(''),
          throwsA(isA<DataSourceFailure>().having(
            (failure) => failure.userMessage,
            'userMessage',
            contains('ÁµêÊûú ID ‰∏çËÉΩÁÇ∫Á©∫'),
          )),
        );
      });
    });

    group('cleanupOldResults', () {
      test('should cleanup old results and return count', () async {
        // Arrange
        final oldDate = DateTime.now().subtract(const Duration(days: 35));
        final recentDate = DateTime.now().subtract(const Duration(days: 15));

        // Êñ∞Â¢û‰∏Ä‰∫õËàäÁµêÊûú
        for (int i = 0; i < 3; i++) {
          when(() => mockUuid.v4()).thenReturn('old-result-$i');
          await cacheService.saveResult(testOCRResult.copyWith(
            processedAt: oldDate,
            rawText: 'Old result $i',
          ));
        }

        // Êñ∞Â¢û‰∏Ä‰∫õÊñ∞ÁµêÊûú
        for (int i = 0; i < 2; i++) {
          when(() => mockUuid.v4()).thenReturn('recent-result-$i');
          await cacheService.saveResult(testOCRResult.copyWith(
            processedAt: recentDate,
            rawText: 'Recent result $i',
          ));
        }

        // Act
        final deletedCount = await cacheService.cleanupOldResults(daysOld: 30);

        // Assert
        expect(deletedCount, equals(3)); // Âè™ÊúâËàäÁöÑÁµêÊûúË¢´Âà™Èô§
        
        final remainingHistory = await cacheService.getHistory();
        expect(remainingHistory, hasLength(2)); // Êñ∞ÁöÑÁµêÊûú‰øùÁïô
      });

      test('should return 0 when no old results to cleanup', () async {
        // Arrange
        when(() => mockUuid.v4()).thenReturn('recent-result');
        await cacheService.saveResult(testOCRResult); // Êñ∞ÁöÑÁµêÊûú

        // Act
        final deletedCount = await cacheService.cleanupOldResults(daysOld: 30);

        // Assert
        expect(deletedCount, equals(0));
        
        final history = await cacheService.getHistory();
        expect(history, hasLength(1)); // ÁµêÊûú‰øùÁïô
      });

      test('should throw DataSourceFailure for invalid days parameter', () async {
        // Act & Assert
        await expectLater(
          cacheService.cleanupOldResults(daysOld: 0),
          throwsA(isA<DataSourceFailure>().having(
            (failure) => failure.userMessage,
            'userMessage',
            contains('Ê∏ÖÁêÜÂ§©Êï∏ÂøÖÈ†àÂ§ßÊñº 0'),
          )),
        );

        await expectLater(
          cacheService.cleanupOldResults(daysOld: -5),
          throwsA(isA<DataSourceFailure>()),
        );
      });
    });

    group('getStatistics', () {
      test('should return default statistics when no data exists', () async {
        // Act
        final stats = await cacheService.getStatistics();

        // Assert
        expect(stats.totalProcessed, equals(0));
        expect(stats.averageConfidence, equals(0.0));
        expect(stats.averageProcessingTimeMs, equals(0.0));
        expect(stats.engineUsage, isEmpty);
        expect(stats.languageConfidence, isEmpty);
      });

      test('should calculate statistics correctly with multiple results', () async {
        // Arrange
        final results = [
          testOCRResult.copyWith(confidence: 0.9, processingTimeMs: 1000, ocrEngine: 'engine_a'),
          testOCRResult.copyWith(confidence: 0.8, processingTimeMs: 1200, ocrEngine: 'engine_a'),
          testOCRResult.copyWith(confidence: 0.7, processingTimeMs: 800, ocrEngine: 'engine_b'),
        ];

        for (int i = 0; i < results.length; i++) {
          when(() => mockUuid.v4()).thenReturn('stats-test-$i');
          await cacheService.saveResult(results[i]);
        }

        // Act
        final stats = await cacheService.getStatistics();

        // Assert
        expect(stats.totalProcessed, equals(3));
        expect(stats.averageConfidence, closeTo(0.8, 0.01)); // (0.9 + 0.8 + 0.7) / 3
        expect(stats.averageProcessingTimeMs, closeTo(1000.0, 1.0)); // (1000 + 1200 + 800) / 3
        expect(stats.engineUsage['engine_a'], equals(2));
        expect(stats.engineUsage['engine_b'], equals(1));
      });

      test('should handle null processing time in statistics', () async {
        // Arrange
        when(() => mockUuid.v4()).thenReturn('stats-null-time');
        await cacheService.saveResult(testOCRResult.copyWith(processingTimeMs: null));

        // Act
        final stats = await cacheService.getStatistics();

        // Assert
        expect(stats.totalProcessed, equals(1));
        expect(stats.averageProcessingTimeMs, equals(0.0));
      });

      test('should handle null engine name in statistics', () async {
        // Arrange
        when(() => mockUuid.v4()).thenReturn('stats-null-engine');
        await cacheService.saveResult(testOCRResult.copyWith(ocrEngine: null));

        // Act
        final stats = await cacheService.getStatistics();

        // Assert
        expect(stats.totalProcessed, equals(1));
        expect(stats.engineUsage['unknown'], equals(1));
      });
    });

    group('cache size management', () {
      test('should handle cache within normal limits', () async {
        // Arrange
        for (int i = 0; i < 50; i++) {
          when(() => mockUuid.v4()).thenReturn('cache-size-$i');
          await cacheService.cacheResult(
            'cache-key-$i',
            testOCRResult.copyWith(rawText: 'Result $i'),
          );
        }

        // Act
        final history = await cacheService.getHistory(limit: 100);

        // Assert
        expect(history.length, equals(50));
      });
    });

    group('JSON serialization edge cases', () {
      test('should handle complex detected texts with special characters', () async {
        // Arrange
        const testId = 'json-test-001';
        final complexResult = testOCRResult.copyWith(
          detectedTexts: [
            'ÁâπÊÆäÂ≠óÁ¨¶: "ÂºïËôü", \'ÂñÆÂºïËôü\'',
            'JSON: {"key": "value"}',
            'Unicode: ‰∏≠ÊñáÊ∏¨Ë©¶ üöÄ √©mojis',
            'Newlines:\nMultiple\nLines',
          ],
        );
        
        when(() => mockUuid.v4()).thenReturn(testId);

        // Act
        await cacheService.saveResult(complexResult);
        final retrieved = await cacheService.getResultById(testId);

        // Assert
        expect(retrieved.detectedTexts, equals(complexResult.detectedTexts));
      });

      test('should handle corrupted JSON gracefully', () async {
        // This test would require direct database manipulation
        // to insert corrupted JSON data, which is complex in this context.
        // In a real-world scenario, you might use database injection
        // or create test data with invalid JSON.
        
        // For now, we'll test the normal JSON handling
        const testId = 'json-test-002';
        when(() => mockUuid.v4()).thenReturn(testId);

        final result = testOCRResult.copyWith(detectedTexts: ['Valid text']);
        await cacheService.saveResult(result);
        final retrieved = await cacheService.getResultById(testId);

        expect(retrieved.detectedTexts, equals(['Valid text']));
      });
    });

    group('concurrent access', () {
      test('should handle concurrent cache operations', () async {
        // Arrange
        final futures = <Future>[];
        
        for (int i = 0; i < 10; i++) {
          when(() => mockUuid.v4()).thenReturn('concurrent-$i');
          
          futures.add(cacheService.saveResult(testOCRResult.copyWith(
            rawText: 'Concurrent result $i',
          )));
        }

        // Act
        await Future.wait(futures);

        // Assert
        final history = await cacheService.getHistory(limit: 20);
        expect(history.length, equals(10));
        
        // È©óË≠âÊâÄÊúâÁµêÊûúÈÉΩÊ≠£Á¢∫ÂÑ≤Â≠ò
        final textContents = history.map((r) => r.rawText).toSet();
        expect(textContents.length, equals(10)); // ÊâÄÊúâÁµêÊûúÈÉΩ‰∏çÂêå
      });
    });
  });
}